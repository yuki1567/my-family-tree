import { defineEventHandler } from 'h3';
import { mount } from '@vue/test-utils';
import { reactive, h as h$1, Suspense, nextTick, isReadonly, unref, effectScope } from 'vue';
import { createDefu, defu } from 'defu';
import { defineComponent, useRouter, h, tryUseNuxtApp } from '#imports';
import NuxtRoot from '#build/root-component.mjs';

function registerEndpoint(url, options) {
  const app = window.__app;
  if (!app)
    return;
  const config = typeof options === "function" ? {
    handler: options,
    method: void 0
  } : options;
  app.use("/_" + url, defineEventHandler(config.handler), {
    match(_, event) {
      return config.method ? event?.method === config.method : true;
    }
  });
  window.__registry.add(url);
}
function mockNuxtImport(_name, _factory) {
  throw new Error(
    "mockNuxtImport() is a macro and it did not get transpiled. This may be an internal bug of @nuxt/test-utils."
  );
}
function mockComponent(_path, _component) {
  throw new Error(
    "mockComponent() is a macro and it did not get transpiled. This may be an internal bug of @nuxt/test-utils."
  );
}

const RouterLink = defineComponent({
  functional: true,
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    custom: Boolean,
    replace: Boolean,
    // Not implemented
    activeClass: String,
    exactActiveClass: String,
    ariaCurrentValue: String
  },
  setup: (props, { slots }) => {
    const navigate = () => {
    };
    return () => {
      const route = useRouter().resolve(props.to);
      return props.custom ? slots.default?.({ href: route.href, navigate, route }) : h(
        "a",
        {
          href: route.href,
          onClick: (e) => {
            e.preventDefault();
            return navigate();
          }
        },
        slots
      );
    };
  }
});

async function mountSuspended(component, options) {
  const {
    props = {},
    attrs = {},
    slots = {},
    route = "/",
    ..._options
  } = options || {};
  const vueApp = tryUseNuxtApp()?.vueApp || globalThis.__unctx__.get("nuxt-app").tryUse().vueApp;
  const { render, setup, data, computed, methods } = component;
  let setupContext;
  let setupState;
  const setProps = reactive({});
  let passedProps;
  const wrappedSetup = async (props2, setupContext2) => {
    passedProps = props2;
    if (setup) {
      const result = await setup(props2, setupContext2);
      setupState = result && typeof result === "object" ? result : {};
      return result;
    }
  };
  return new Promise(
    (resolve) => {
      const vm = mount(
        {
          setup: (props2, ctx) => {
            setupContext = ctx;
            return NuxtRoot.setup(props2, {
              ...ctx,
              expose: () => {
              }
            });
          },
          render: (renderContext) => h$1(
            Suspense,
            {
              onResolve: () => nextTick().then(() => {
                vm.setupState = setupState;
                vm.__setProps = (props2) => {
                  Object.assign(setProps, props2);
                };
                resolve(vm);
              })
            },
            {
              default: () => h$1({
                name: "MountSuspendedHelper",
                async setup() {
                  const router = useRouter();
                  await router.replace(route);
                  const clonedComponent = {
                    name: "MountSuspendedComponent",
                    ...component,
                    render: render ? function(_ctx, ...args) {
                      if (data && typeof data === "function") {
                        const dataObject = data();
                        for (const key in dataObject) {
                          renderContext[key] = dataObject[key];
                        }
                      }
                      for (const key in setupState || {}) {
                        renderContext[key] = isReadonly(setupState[key]) ? unref(setupState[key]) : setupState[key];
                      }
                      for (const key in props || {}) {
                        renderContext[key] = _ctx[key];
                      }
                      for (const key in passedProps || {}) {
                        renderContext[key] = passedProps[key];
                      }
                      if (methods && typeof methods === "object") {
                        for (const key in methods) {
                          renderContext[key] = methods[key];
                        }
                      }
                      if (computed && typeof computed === "object") {
                        for (const key in computed) {
                          renderContext[key] = computed[key].call(renderContext);
                        }
                      }
                      return render.call(this, renderContext, ...args);
                    } : void 0,
                    setup: setup ? (props2) => wrappedSetup(props2, setupContext) : void 0
                  };
                  return () => h$1(clonedComponent, { ...defuReplaceArray(setProps, props), ...attrs }, slots);
                }
              })
            }
          )
        },
        defu(
          _options,
          {
            slots,
            global: {
              config: {
                globalProperties: vueApp.config.globalProperties
              },
              directives: vueApp._context.directives,
              provide: vueApp._context.provides,
              stubs: {
                Suspense: false,
                MountSuspendedHelper: false,
                [component && typeof component === "object" && "name" in component && typeof component.name === "string" ? component.name : "MountSuspendedComponent"]: false
              },
              components: { RouterLink }
            }
          }
        )
      );
    }
  );
}
const defuReplaceArray = createDefu((obj, key, value) => {
  if (Array.isArray(obj[key])) {
    obj[key] = value;
    return true;
  }
});

const WRAPPER_EL_ID = "test-wrapper";
async function renderSuspended(component, options) {
  const {
    props = {},
    attrs = {},
    slots = {},
    route = "/",
    ..._options
  } = options || {};
  const { render: renderFromTestingLibrary } = await import('@testing-library/vue');
  const vueApp = tryUseNuxtApp()?.vueApp || globalThis.__unctx__.get("nuxt-app").tryUse().vueApp;
  const { render, setup, data, computed, methods } = component;
  let setupContext;
  let setupState;
  for (const fn of window.__cleanup || []) {
    fn();
  }
  document.querySelector(`#${WRAPPER_EL_ID}`)?.remove();
  let passedProps;
  const wrappedSetup = async (props2, setupContext2) => {
    passedProps = props2;
    if (setup) {
      const result = await setup(props2, setupContext2);
      setupState = result && typeof result === "object" ? result : {};
      return result;
    }
  };
  return new Promise((resolve) => {
    const utils = renderFromTestingLibrary(
      {
        setup: (props2, ctx) => {
          setupContext = ctx;
          const scope = effectScope();
          window.__cleanup || (window.__cleanup = []);
          window.__cleanup.push(() => {
            scope.stop();
          });
          return scope.run(() => NuxtRoot.setup(props2, {
            ...ctx,
            expose: () => ({})
          }));
        },
        render: (renderContext) => (
          // See discussions in https://github.com/testing-library/vue-testing-library/issues/230
          // we add this additional root element because otherwise testing-library breaks
          // because there's no root element while Suspense is resolving
          h$1(
            "div",
            { id: WRAPPER_EL_ID },
            h$1(
              Suspense,
              {
                onResolve: () => nextTick().then(() => {
                  utils.setupState = setupState;
                  resolve(utils);
                })
              },
              {
                default: () => h$1({
                  name: "RenderHelper",
                  async setup() {
                    const router = useRouter();
                    await router.replace(route);
                    const clonedComponent = {
                      name: "RenderSuspendedComponent",
                      ...component,
                      render: render ? function(_ctx, ...args) {
                        if (data && typeof data === "function") {
                          const dataObject = data();
                          for (const key in dataObject) {
                            renderContext[key] = dataObject[key];
                          }
                        }
                        for (const key in setupState || {}) {
                          renderContext[key] = isReadonly(setupState[key]) ? unref(setupState[key]) : setupState[key];
                        }
                        for (const key in props || {}) {
                          renderContext[key] = _ctx[key];
                        }
                        for (const key in passedProps || {}) {
                          renderContext[key] = passedProps[key];
                        }
                        if (methods && typeof methods === "object") {
                          for (const key in methods) {
                            renderContext[key] = methods[key];
                          }
                        }
                        if (computed && typeof computed === "object") {
                          for (const key in computed) {
                            renderContext[key] = computed[key].call(renderContext);
                          }
                        }
                        return render.call(this, renderContext, ...args);
                      } : void 0,
                      setup: setup ? (props2) => wrappedSetup(props2, setupContext) : void 0
                    };
                    return () => h$1(clonedComponent, { ...props && typeof props === "object" ? props : {}, ...attrs }, slots);
                  }
                })
              }
            )
          )
        )
      },
      defu(_options, {
        slots,
        global: {
          config: {
            globalProperties: vueApp.config.globalProperties
          },
          directives: vueApp._context.directives,
          provide: vueApp._context.provides,
          components: { RouterLink }
        }
      })
    );
  });
}

export { mockComponent, mockNuxtImport, mountSuspended, registerEndpoint, renderSuspended };
