{"version":3,"file":"hasReturnValue.cjs","names":["isNewPromiseExpression","node","type","callee","name","isVoidPromise","_node$typeArguments","_node$typeParameters","typeArguments","params","typeParameters","undefinedKeywords","Set","hasReturnValue","throwOnNullReturn","promFilter","expression","body","some","bodyNode","consequent","alternate","value","argument","Error","cases","someCase","nde","block","handler","finalizer","_node$returnType","returnType","typeAnnotation","has","exports","allBrancheshaveReturnValues","lastBodyNode","slice","test","every","consNode","error","message","_node$returnType2","hasNonEmptyResolverCall","resolverName","elements","element","_node$params$","left","right","arguments","length","undefined","decorators","decorator","computed","key","source","object","property","properties","expressions","subExpression","quasi","declarations","id","init","hasValueOrExecutorHasNonEmptyResolveValue","anyPromiseAsReturn","allBranches","hasReturnMethod","promiseFilter","hasReturn","Boolean","prom"],"sources":["../../src/utils/hasReturnValue.js"],"sourcesContent":["/**\n * @typedef {import('estree').Node|\n *   import('@typescript-eslint/types').TSESTree.Node} ESTreeOrTypeScriptNode\n */\n\n/**\n * Checks if a node is a promise but has no resolve value or an empty value.\n * An `undefined` resolve does not count.\n * @param {ESTreeOrTypeScriptNode|undefined|null} node\n * @returns {boolean|undefined|null}\n */\nconst isNewPromiseExpression = (node) => {\n  return node && node.type === 'NewExpression' && node.callee.type === 'Identifier' &&\n    node.callee.name === 'Promise';\n};\n\n/**\n * @param {ESTreeOrTypeScriptNode|null|undefined} node\n * @returns {boolean}\n */\nconst isVoidPromise = (node) => {\n  return /** @type {import('@typescript-eslint/types').TSESTree.TSTypeReference} */ (node)?.typeArguments?.params?.[0]?.type === 'TSVoidKeyword'\n    /* c8 ignore next 5 */\n    // eslint-disable-next-line @stylistic/operator-linebreak -- c8\n    || /** @type {import('@typescript-eslint/types').TSESTree.TSTypeReference} */ (\n      node\n    // @ts-expect-error Ok\n    )?.typeParameters?.params?.[0]?.type === 'TSVoidKeyword';\n};\n\nconst undefinedKeywords = new Set([\n  'TSNeverKeyword', 'TSUndefinedKeyword', 'TSVoidKeyword',\n]);\n\n/**\n * Checks if a node has a return statement. Void return does not count.\n * @param {ESTreeOrTypeScriptNode|undefined|null} node\n * @param {boolean} [throwOnNullReturn]\n * @param {PromiseFilter} [promFilter]\n * @returns {boolean|undefined}\n */\n// eslint-disable-next-line complexity\nconst hasReturnValue = (node, throwOnNullReturn, promFilter) => {\n  if (!node) {\n    return false;\n  }\n\n  switch (node.type) {\n    case 'ArrowFunctionExpression':\n    case 'FunctionDeclaration':\n    case 'FunctionExpression': {\n      return 'expression' in node && node.expression && (!isNewPromiseExpression(\n        node.body,\n      ) || !isVoidPromise(node.body)) ||\n      hasReturnValue(node.body, throwOnNullReturn, promFilter);\n    }\n\n    case 'BlockStatement': {\n      return node.body.some((bodyNode) => {\n        return bodyNode.type !== 'FunctionDeclaration' && hasReturnValue(bodyNode, throwOnNullReturn, promFilter);\n      });\n    }\n\n    case 'DoWhileStatement':\n    case 'ForInStatement':\n    case 'ForOfStatement':\n\n    case 'ForStatement':\n\n    case 'LabeledStatement':\n    case 'WhileStatement':\n    case 'WithStatement': {\n      return hasReturnValue(node.body, throwOnNullReturn, promFilter);\n    }\n\n    case 'IfStatement': {\n      return hasReturnValue(node.consequent, throwOnNullReturn, promFilter) ||\n      hasReturnValue(node.alternate, throwOnNullReturn, promFilter);\n    }\n\n    case 'MethodDefinition':\n      return hasReturnValue(node.value, throwOnNullReturn, promFilter);\n    case 'ReturnStatement': {\n    // void return does not count.\n      if (node.argument === null) {\n        if (throwOnNullReturn) {\n          throw new Error('Null return');\n        }\n\n        return false;\n      }\n\n      if (promFilter && isNewPromiseExpression(node.argument)) {\n      // Let caller decide how to filter, but this is, at the least,\n      //   a return of sorts and truthy\n        return promFilter(node.argument);\n      }\n\n      return true;\n    }\n\n    case 'SwitchStatement': {\n      return node.cases.some(\n        (someCase) => {\n          return someCase.consequent.some((nde) => {\n            return hasReturnValue(nde, throwOnNullReturn, promFilter);\n          });\n        },\n      );\n    }\n\n    case 'TryStatement': {\n      return hasReturnValue(node.block, throwOnNullReturn, promFilter) ||\n      hasReturnValue(node.handler && node.handler.body, throwOnNullReturn, promFilter) ||\n      hasReturnValue(node.finalizer, throwOnNullReturn, promFilter);\n    }\n\n    case 'TSDeclareFunction':\n\n    case 'TSFunctionType':\n\n    case 'TSMethodSignature': {\n      const type = node?.returnType?.typeAnnotation?.type;\n      return type && !undefinedKeywords.has(type);\n    }\n\n    default: {\n      return false;\n    }\n  }\n};\n\n/**\n * Checks if a node has a return statement. Void return does not count.\n * @param {ESTreeOrTypeScriptNode|null|undefined} node\n * @param {PromiseFilter} promFilter\n * @returns {undefined|boolean|ESTreeOrTypeScriptNode}\n */\n// eslint-disable-next-line complexity\nconst allBrancheshaveReturnValues = (node, promFilter) => {\n  if (!node) {\n    return false;\n  }\n\n  switch (node.type) {\n    // case 'MethodDefinition':\n    //   return allBrancheshaveReturnValues(node.value, promFilter);\n    case 'ArrowFunctionExpression':\n    case 'FunctionDeclaration':\n    case 'FunctionExpression': {\n      return 'expression' in node && node.expression && (!isNewPromiseExpression(node.body) || !isVoidPromise(node.body)) ||\n      allBrancheshaveReturnValues(node.body, promFilter) ||\n      /** @type {import('@typescript-eslint/types').TSESTree.BlockStatement} */\n      (node.body).body.some((nde) => {\n        return nde.type === 'ReturnStatement';\n      });\n    }\n\n    case 'BlockStatement': {\n      const lastBodyNode = node.body.slice(-1)[0];\n      return allBrancheshaveReturnValues(lastBodyNode, promFilter);\n    }\n\n    case 'DoWhileStatement':\n    case 'WhileStatement':\n      if (\n      /**\n       * @type {import('@typescript-eslint/types').TSESTree.Literal}\n       */\n        (node.test).value === true\n      ) {\n      // If this is an infinite loop, we assume only one branch\n      //   is needed to provide a return\n        return hasReturnValue(node.body, false, promFilter);\n      }\n\n    // Fallthrough\n    case 'ForStatement':\n      if (node.test === null) {\n      // If this is an infinite loop, we assume only one branch\n      //   is needed to provide a return\n        return hasReturnValue(node.body, false, promFilter);\n      }\n\n    case 'ForInStatement':\n    case 'ForOfStatement':\n\n    case 'LabeledStatement':\n\n    case 'WithStatement': {\n      return allBrancheshaveReturnValues(node.body, promFilter);\n    }\n\n    case 'IfStatement': {\n      return allBrancheshaveReturnValues(node.consequent, promFilter) &&\n      allBrancheshaveReturnValues(node.alternate, promFilter);\n    }\n\n    case 'ReturnStatement': {\n    // void return does not count.\n      if (node.argument === null) {\n        return false;\n      }\n\n      if (promFilter && isNewPromiseExpression(node.argument)) {\n      // Let caller decide how to filter, but this is, at the least,\n      //   a return of sorts and truthy\n        return promFilter(node.argument);\n      }\n\n      return true;\n    }\n\n    case 'SwitchStatement': {\n      return /** @type {import('@typescript-eslint/types').TSESTree.SwitchStatement} */ (node).cases.every(\n        (someCase) => {\n          return !someCase.consequent.some((consNode) => {\n            return consNode.type === 'BreakStatement' ||\n            consNode.type === 'ReturnStatement' && consNode.argument === null;\n          });\n        },\n      );\n    }\n\n    case 'ThrowStatement': {\n      return true;\n    }\n\n    case 'TryStatement': {\n    // If `finally` returns, all return\n      return node.finalizer && allBrancheshaveReturnValues(node.finalizer, promFilter) ||\n      // Return in `try`/`catch` may still occur despite `finally`\n      allBrancheshaveReturnValues(node.block, promFilter) &&\n        (!node.handler ||\n          allBrancheshaveReturnValues(node.handler && node.handler.body, promFilter)) &&\n          (!node.finalizer || (() => {\n            try {\n              hasReturnValue(node.finalizer, true, promFilter);\n            } catch (error) {\n              if (/** @type {Error} */ (error).message === 'Null return') {\n                return false;\n              }\n              /* c8 ignore next 3 */\n              // eslint-disable-next-line @stylistic/padding-line-between-statements -- c8\n              throw error;\n            }\n\n            // As long as not an explicit empty return, then return true\n            return true;\n          })());\n    }\n\n    case 'TSDeclareFunction':\n\n    case 'TSFunctionType':\n\n    case 'TSMethodSignature': {\n      const type = node?.returnType?.typeAnnotation?.type;\n      return type && !undefinedKeywords.has(type);\n    }\n\n    default: {\n      return false;\n    }\n  }\n};\n\n/**\n * @callback PromiseFilter\n * @param {ESTreeOrTypeScriptNode|undefined} node\n * @returns {boolean}\n */\n\n/**\n * Avoids further checking child nodes if a nested function shadows the\n * resolver, but otherwise, if name is used (by call or passed in as an\n * argument to another function), will be considered as non-empty.\n *\n * This could check for redeclaration of the resolver, but as such is\n * unlikely, we avoid the performance cost of checking everywhere for\n * (re)declarations or assignments.\n * @param {import('@typescript-eslint/types').TSESTree.Node|null|undefined} node\n * @param {string} resolverName\n * @returns {boolean}\n */\n// eslint-disable-next-line complexity\nconst hasNonEmptyResolverCall = (node, resolverName) => {\n  if (!node) {\n    return false;\n  }\n\n  // Arrow function without block\n  switch (node.type) {\n    case 'ArrayExpression':\n    case 'ArrayPattern':\n      return node.elements.some((element) => {\n        return hasNonEmptyResolverCall(element, resolverName);\n      });\n    case 'ArrowFunctionExpression':\n    case 'FunctionDeclaration':\n    case 'FunctionExpression': {\n    // Shadowing\n      if (/** @type {import('@typescript-eslint/types').TSESTree.Identifier} */ (\n        node.params[0]\n      )?.name === resolverName) {\n        return false;\n      }\n\n      return hasNonEmptyResolverCall(node.body, resolverName);\n    }\n\n    case 'AssignmentExpression':\n    case 'BinaryExpression':\n    case 'LogicalExpression': {\n      return hasNonEmptyResolverCall(node.left, resolverName) ||\n      hasNonEmptyResolverCall(node.right, resolverName);\n    }\n\n    case 'AssignmentPattern':\n      return hasNonEmptyResolverCall(node.right, resolverName);\n    case 'AwaitExpression':\n\n    case 'SpreadElement':\n    case 'UnaryExpression':\n    case 'YieldExpression':\n      return hasNonEmptyResolverCall(node.argument, resolverName);\n    case 'BlockStatement':\n    case 'ClassBody':\n      return node.body.some((bodyNode) => {\n        return hasNonEmptyResolverCall(bodyNode, resolverName);\n      });\n      /* c8 ignore next 2 -- In Babel? */\n    case 'CallExpression':\n      // @ts-expect-error Babel?\n    case 'OptionalCallExpression':\n      return /** @type {import('@typescript-eslint/types').TSESTree.Identifier} */ (\n        node.callee\n      ).name === resolverName && (\n\n      // Implicit or explicit undefined\n        node.arguments.length > 1 || node.arguments[0] !== undefined\n      ) ||\n      node.arguments.some((nde) => {\n        // Being passed in to another function (which might invoke it)\n        return nde.type === 'Identifier' && nde.name === resolverName ||\n\n          // Handle nested items\n          hasNonEmptyResolverCall(nde, resolverName);\n      });\n\n    case 'ChainExpression':\n    case 'Decorator':\n\n    case 'ExpressionStatement':\n      return hasNonEmptyResolverCall(node.expression, resolverName);\n\n    case 'ClassDeclaration':\n\n    case 'ClassExpression':\n      return hasNonEmptyResolverCall(node.body, resolverName);\n      /* c8 ignore next 2 -- In Babel? */\n      // @ts-expect-error Babel?\n    case 'ClassMethod':\n\n    case 'MethodDefinition':\n      return node.decorators && node.decorators.some((decorator) => {\n        return hasNonEmptyResolverCall(decorator, resolverName);\n      }) ||\n      node.computed && hasNonEmptyResolverCall(node.key, resolverName) ||\n      hasNonEmptyResolverCall(node.value, resolverName);\n\n    /* c8 ignore next 2 -- In Babel? */\n      // @ts-expect-error Babel?\n    case 'ClassProperty':\n    /* c8 ignore next 2 -- In Babel? */\n    // @ts-expect-error Babel?\n    case 'ObjectProperty':\n    case 'Property':\n\n    case 'PropertyDefinition':\n      return node.computed && hasNonEmptyResolverCall(node.key, resolverName) ||\n      hasNonEmptyResolverCall(node.value, resolverName);\n    case 'ConditionalExpression':\n\n    case 'IfStatement': {\n      return hasNonEmptyResolverCall(node.test, resolverName) ||\n      hasNonEmptyResolverCall(node.consequent, resolverName) ||\n      hasNonEmptyResolverCall(node.alternate, resolverName);\n    }\n\n    case 'DoWhileStatement':\n    case 'ForInStatement':\n    case 'ForOfStatement':\n\n    case 'ForStatement':\n    case 'LabeledStatement':\n    case 'WhileStatement':\n    case 'WithStatement': {\n      return hasNonEmptyResolverCall(node.body, resolverName);\n    }\n\n    /* c8 ignore next 2 -- In Babel? */\n    // @ts-expect-error Babel?\n    case 'Import':\n\n    case 'ImportExpression':\n      return hasNonEmptyResolverCall(node.source, resolverName);\n      // ?.\n      /* c8 ignore next 2 -- In Babel? */\n    case 'MemberExpression':\n\n    // @ts-expect-error Babel?\n    case 'OptionalMemberExpression':\n      return hasNonEmptyResolverCall(node.object, resolverName) ||\n      hasNonEmptyResolverCall(node.property, resolverName);\n    case 'ObjectExpression':\n    case 'ObjectPattern':\n      return node.properties.some((property) => {\n        return hasNonEmptyResolverCall(property, resolverName);\n      });\n    /* c8 ignore next 2 -- In Babel? */\n      // @ts-expect-error Babel?\n    case 'ObjectMethod':\n    /* c8 ignore next 6 -- In Babel? */\n    // @ts-expect-error\n      return node.computed && hasNonEmptyResolverCall(node.key, resolverName) ||\n      // @ts-expect-error\n      node.arguments.some((nde) => {\n        return hasNonEmptyResolverCall(nde, resolverName);\n      });\n\n    case 'ReturnStatement': {\n      if (node.argument === null) {\n        return false;\n      }\n\n      return hasNonEmptyResolverCall(node.argument, resolverName);\n    }\n\n    // Comma\n    case 'SequenceExpression':\n\n    case 'TemplateLiteral':\n      return node.expressions.some((subExpression) => {\n        return hasNonEmptyResolverCall(subExpression, resolverName);\n      });\n\n    case 'SwitchStatement': {\n      return node.cases.some(\n        (someCase) => {\n          return someCase.consequent.some((nde) => {\n            return hasNonEmptyResolverCall(nde, resolverName);\n          });\n        },\n      );\n    }\n\n    case 'TaggedTemplateExpression':\n      return hasNonEmptyResolverCall(node.quasi, resolverName);\n\n    case 'TryStatement': {\n      return hasNonEmptyResolverCall(node.block, resolverName) ||\n      hasNonEmptyResolverCall(node.handler && node.handler.body, resolverName) ||\n      hasNonEmptyResolverCall(node.finalizer, resolverName);\n    }\n\n    case 'VariableDeclaration': {\n      return node.declarations.some((nde) => {\n        return hasNonEmptyResolverCall(nde, resolverName);\n      });\n    }\n\n    case 'VariableDeclarator': {\n      return hasNonEmptyResolverCall(node.id, resolverName) ||\n      hasNonEmptyResolverCall(node.init, resolverName);\n    }\n\n    /*\n  // Shouldn't need to parse literals/literal components, etc.\n\n  case 'Identifier':\n  case 'TemplateElement':\n  case 'Super':\n  // Exports not relevant in this context\n  */\n    default:\n      return false;\n  }\n};\n\n/**\n * Checks if a Promise executor has no resolve value or an empty value.\n * An `undefined` resolve does not count.\n * @param {ESTreeOrTypeScriptNode} node\n * @param {boolean} anyPromiseAsReturn\n * @param {boolean} [allBranches]\n * @returns {boolean}\n */\nconst hasValueOrExecutorHasNonEmptyResolveValue = (node, anyPromiseAsReturn, allBranches) => {\n  const hasReturnMethod = allBranches ?\n    /**\n     * @param {ESTreeOrTypeScriptNode} nde\n     * @param {PromiseFilter} promiseFilter\n     * @returns {boolean}\n     */\n    (nde, promiseFilter) => {\n      let hasReturn;\n      try {\n        hasReturn = hasReturnValue(nde, true, promiseFilter);\n      } catch (error) {\n        // c8 ignore else\n        if (/** @type {Error} */ (error).message === 'Null return') {\n          return false;\n        }\n        /* c8 ignore next 3 */\n        // eslint-disable-next-line @stylistic/padding-line-between-statements -- c8\n        throw error;\n      }\n\n      // `hasReturn` check needed since `throw` treated as valid return by\n      //   `allBrancheshaveReturnValues`\n      return Boolean(hasReturn && allBrancheshaveReturnValues(nde, promiseFilter));\n    } :\n    /**\n     * @param {ESTreeOrTypeScriptNode} nde\n     * @param {PromiseFilter} promiseFilter\n     * @returns {boolean}\n     */\n    (nde, promiseFilter) => {\n      return Boolean(hasReturnValue(nde, false, promiseFilter));\n    };\n\n  return hasReturnMethod(node, (prom) => {\n    if (anyPromiseAsReturn) {\n      return true;\n    }\n\n    if (isVoidPromise(prom)) {\n      return false;\n    }\n\n    const {\n      body,\n      params,\n    } =\n    /**\n     * @type {import('@typescript-eslint/types').TSESTree.FunctionExpression|\n     * import('@typescript-eslint/types').TSESTree.ArrowFunctionExpression}\n     */ (\n      /** @type {import('@typescript-eslint/types').TSESTree.NewExpression} */ (\n          prom\n        ).arguments[0]\n      ) || {};\n\n    if (!params?.length) {\n      return false;\n    }\n\n    const {\n      name: resolverName,\n    } = /** @type {import('@typescript-eslint/types').TSESTree.Identifier} */ (\n      params[0]\n    );\n\n    return hasNonEmptyResolverCall(body, resolverName);\n  });\n};\n\nexport {\n  hasReturnValue,\n  hasValueOrExecutorHasNonEmptyResolveValue,\n};\n"],"mappings":"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","ignoreList":[]}